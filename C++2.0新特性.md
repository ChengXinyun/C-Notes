1. `Variadic Templates`

   数量不定的模板参数

2. Space in Template Expressions

   vector<list<int> > 

   vector<list<int>>

3. `nullptr 和 std::nullptr_t`

   - `用nullptr去代替 0 和NULL；`
   - `nullptr 的 type 是 std::nullptr_t, 定义在<cstddef>中`

4. auto

   `auto i = 42；// i has type int`

   `double f();`

   `auto d = f(); // d has type double`

   编译器做实参推导； 

   变量的类型名称太长或者是一个很复杂的表达式，可以使用auto，不要在任何地方都使用auto；

   在lambda表达式中；

5. Uniform Initialization

   变量后面直接加大括号

   int values[] {1,2,3};

   vector<int> v{1,2,3,43,4,5,5};

   编译器看到大括号，便做出一个initializer_list<T>,它内部关联至一个array<T,n>。调用函数（例如`ctor`）时该array内的元素可被编译器分解逐一传给函数。但若函数参数是个initializer_list<T>，调用者不能给数个T参数以为它们会自动转为initializer_list<T>，需要准备好initializer_list<T>，然后再传给它。

6. 

7. 







